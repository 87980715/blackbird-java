main:
	Read blackbird.conf params into Parameters instance
	Create an instance of Main and call runBlackbird
	
runBlackbird:
	print intro text
	call initResources
	main loop: while we haven't requested program stoppage
		sleep a short delay
		check for the presence of a new quote
		if one exists
			call processNewQuotes
	when stoppage requested:
		notify all listeners that we're quitting

initResources
	for every class in the com.slickapps.blackbird.exchanges package that implements BlackbirdExchange
		create an instance, providing the Parameters instance (see BlackBirdExchange constructor below)
	attempt to read in a saved file containing JSON representation of the ExchangePairsInMarket class
		if none found, use an empty new instance
	add event listeners for:
		CSV order completion DAO - this writes all completed arbitrage transactions (profits) to an output CSV file
		DB quote writer - this simply stores all quotes as they arrive to a SQLite database - unused for now
		Spread monitor - this monitors incoming quotes and updates the min and max spreads across exchanges
		Volatility monitor - unused for now
		Auto file save - this monitors any changes to our singleton ExchangePairsInMarket object and (re)writes it to a save file
	initialize quote service - responsible for creating and starting quote generator threads which poll our exchanges
	initialize market entry service - responsible for the business logic necessary to move pairs of exchanges into the market
	initialize market exit service - responsible for business logic to close positions and move pairs of exchanges out of the market
	initialize balance service - responsible for querying the initial wallets (balances) at each exchange
	start exchange wallet poller - responsible for polling the wallet balances at each exchange in a separate threads
	for any exchange pairs already in the market upon program start (i.e. read in from last execution's save file)
		if the pair successfully has entry orders placed, but not yet filled
			start Entry Order Completion pollers (see below)
		if the pair successfully has exit orders placed, but not yet filled
			start Exit Order Completion pollers (see below)
	start all quote generators
	begin the Exit File Monitor, which monitoring for the presence of a file which, if found, will cause the program to gracefully exit
	if specified in the Parameters, start a periodic Status Logger which will summarize any pairs in market to stdout
	
BlackbirdExchange constructor
	read exchange-specific parameters (prefixed with the name of the exchange)
	create an instance of an xchange Exchange for use behind the scenes
	initialize a rate-limited task executor specific to this exchange to ensure we don't exceed our max rate supported

processNewQuotes
	check for exit opportunities for any exchange pairs in market: call marketExitService.prepareNextPairReadyToExit
	if one was returned
		start a pair of Exit Order Completion pollers - see below
		return and restart the main loop
	otherwise, check for entry opportunities for any exchange pairs not in the market: call marketEntryService.prepareNextPairReadyToEnter
	if one was returned
		add it to the singleton ExchangePairsInMarket
		start a pair of Entry Order Completion pollers - see below
		return and restart the main loop

marketExitService.prepareNextPairReadyToExit
	if we don't have any pairs in the market, return immediately
	for each of the pairs currently in the market
		ensure the pair's short and long exchanges are both working (not disabled temporarily due to network issues)
		ensure the pair isn't halfway in the market, due to its two entry orders not being filled yet
		ensure the pair isn't waiting to exit the market, due to 1 or more of its exit orders already being placed
		get the latest quotes generated by the pair's long and short exchanges
		ensure the two quotes are available and are close enough in time to be comparable with one another
		notify all listeners that the quotes are being evaluated (such as the SpreadMonitor)
		call marketExitService.evaluate(the quote pair, the pair currently in market)
		if evaluate returned true (signifying approval)
			call placeLongAndShortOrder
			return this pair in market
	if no pairs in market were approved for exit:
	for each of the pairs currently in the market
		ensure the pair's short and long exchanges are both working (not disabled temporarily due to network issues)
		if only one of the pair's exit orders was placed, but not the other
			call placeLongAndShortOrder to reattempt the failed exit order
			if successful, both orders are now placed - return the pair in market and start Exit Order Completion Pollers (see below)
	finally, if no pairs in market were approved for exit, return null

marketExitService.evaluate(quote pair, exchange pair in market)
	calculate the quote pair's spread: (short exchange's ask - the long exchange's bid) / the long exchange's bid
	if the quote pair doesn't have a valid spread due to either the ask or bid not yet being provided, return false
	get (or create if needed) the trailing stop details for this quote pair
	if the trailing stop details don't approve of this pair exiting yet, return false
	
		
Entry Order Completion Poller:
	